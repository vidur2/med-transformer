"""
Metaprogramming utility to generate Category subclasses with isolated _categories lists.

Usage:
    python generate_category.py DiagnosisCategory diagnosis_category.py
    python generate_category.py ProcedureCategory procedure_category.py
"""

import sys
import os
from pathlib import Path


def generate_category_class(class_name: str, output_file: str):
    """
    Generate a new Category subclass with its own isolated _categories list.
    
    Args:
        class_name: Name of the new class (e.g., "DiagnosisCategory")
        output_file: Target file path to write the class definition
    """
    
    class_code = f'''"""
Auto-generated Category subclass: {class_name}
Generated by generate_category.py
"""

from typing import List
from abstract import Category


class {class_name}(Category):
    """
    {class_name} with isolated category tracking.
    
    This class maintains its own separate _categories list,
    independent of the parent Category class and other subclasses.
    """
    
    # Override the shared class variable with a new list for this subclass
    _categories: List[str] = []
    
    def __init__(self, category_name: str):
        # Don't call super().__init__() to avoid parent's _categories
        # Instead, implement the logic directly with our own _categories
        
        if category_name in self._categories:
            self.cat_ord = self._categories.index(category_name)
        else:
            self._categories.append(category_name)
            self.cat_ord = len(self._categories) - 1
    
    @classmethod
    def get_all_categories(cls) -> List[str]:
        """Return all registered categories for this class."""
        return cls._categories.copy()
    
    @classmethod
    def reset_categories(cls):
        """Clear all registered categories for this class."""
        cls._categories.clear()
    
    @classmethod
    def num_categories(cls) -> int:
        """Return the number of registered categories."""
        return len(cls._categories)
'''
    
    # Write to file
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        f.write(class_code)
    
    print(f"âœ“ Generated {class_name} in {output_file}")
    print(f"  - Isolated _categories list")
    print(f"  - Methods: get_cat(), get_all_categories(), reset_categories(), num_categories()")


def main():
    """Main entry point for the script."""
    if len(sys.argv) < 2:
        print("Usage: python generate_category.py <ClassName> [output_file]")
        print("\nExamples:")
        print("  python generate_category.py DiagnosisCategory")
        print("  python generate_category.py ProcedureCategory procedure_category.py")
        print("  python generate_category.py MedicationCategory ../model/medication_category.py")
        sys.exit(1)
    
    class_name = sys.argv[1]
    
    # Default output file: convert ClassName to class_name.py
    if len(sys.argv) >= 3:
        output_file = sys.argv[2]
    else:
        # Convert CamelCase to snake_case
        import re
        snake_case = re.sub(r'(?<!^)(?=[A-Z])', '_', class_name).lower()
        output_file = f"{snake_case}.py"
    
    # Validate class name
    if not class_name[0].isupper() or not class_name.replace('_', '').isalnum():
        print(f"Error: '{class_name}' is not a valid Python class name")
        print("Class names should be in CamelCase (e.g., DiagnosisCategory)")
        sys.exit(1)
    
    generate_category_class(class_name, output_file)


if __name__ == "__main__":
    main()
